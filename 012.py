#!python


problem = """
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The fi
rst ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

https://projecteuler.net/problem=12

OR

Must find the smallest number t, such that
t = n*(n+1)/2
for all n, also satisfying

t = PI(p^m)
is the prime factorization of t.

The number of divisors is D = PI(m+1)

600 = 2^3 * 3 * 5^2 --> (3+1)(1+1)(2+1) = 24 divisors

SO...

We want to find the smallest number with at least 501 divisors.

501 = 3 * 167
502 = 2 * 251
503 = 1 * 503
504 = 2 * 2 * 2 * 3 * 3 * 7
505 = 5 * 101
506 = 2 * 11 * 23
507 = 3 * 13 * 13
508 = 2 * 2 * 127
509 = 1 * 509
510 = 2 * 5 * 51
511 = 7 * 73
512 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2

1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45

"""

print(problem)

# first get the list of the first X primes:
import math
top=10000
primeset=[2,3]
m=1
x=len(primeset)
def check_prime(n):
  global x,primeset
  primetest=True
  topn=math.sqrt(n)
  for i in primeset:
    if i > topn:
      break
    if (n%i) == 0:
      primetest=False
  if primetest == True:
    primeset.append(n)
    x=len(primeset)
    # print("found",x,n)
while x < top:
  check_prime((6*m)-1)
  check_prime((6*m)+1)
  m+=1


n = 1
while n < 600:
  print()
  tri = int(n * ( n+1 ) /2)
  maxprime = int(math.sqrt(tri))
  print(n,tri,maxprime)
  primsubset = [ x for x in primeset if x <= maxprime ]
  print(primsubset)
  testtri = tri
  listofdivs=[]
  for m in primsubset:
    if testtri % m:
      listofdivs.append(m)


  n+=1
